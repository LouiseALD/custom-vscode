
# query_processing.py - Versão refatorada
# no início do arquivo
import streamlit as st
import traceback
import json
import boto3
import os

# Importações relativas dentro do pacote chatbot
from .sql_utils import validar_query_simplificada, extrair_query_sql
from .state_manager import adicionar_mensagem, adicionar_mensagens_multiplas
from .mapping_utils import MappingManager
from .query_converter import criar_conversor
from logger_config import setup_logger  # Este é externo ao pacote chatbot

logger = setup_logger()

def processar_mensagem_multilinhas(mensagem):
    """
    Processa mensagens com múltiplas linhas, lidando com qualquer número de tabelas.
    
    Args:
        mensagem: Mensagem multilinhas a ser processada
    
    Returns:
        Lista de mensagens a serem adicionadas sequencialmente
    """
    import re
    
    # Verificar se a mensagem contém padrões específicos de múltiplas tabelas
    linhas = mensagem.split('\n')
    mensagens_processadas = []
    
    # Padrões para identificar diferentes partes da mensagem
    padrao_inicio = r"Analisando sua query SQL.*"
    padrao_tabela = r"Foi encontrado para a tabela.*"
    padrao_final = r"Por favor, selecione.*"
    
    for linha in linhas:
        # Limpar espaços extras
        linha = linha.strip()
        
        # Pular linhas vazias
        if not linha:
            continue
        
        # Verificar padrões de mensagem
        if (re.match(padrao_inicio, linha, re.IGNORECASE) or 
            re.match(padrao_tabela, linha, re.IGNORECASE) or 
            re.match(padrao_final, linha, re.IGNORECASE)):
            mensagens_processadas.append(linha)
    
    return mensagens_processadas

def processar_query_valida(query):
    """
    Processa uma query SQL válida e determina as possibilidades de mapeamento.
    
    Args:
        query: Query SQL a ser processada
    """
    # Obter o tipo de conversão e o gerenciador de mapeamentos
    tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
    mapping_manager = st.session_state.get("mapping_manager")

    if not mapping_manager or not mapping_manager.mapeamentos:
            logger.error("Nenhum mapeamento foi carregado. Impossível processar a query.")
            # Mensagem de erro para o usuário
            adicionar_mensagem(
                "assistant", 
                "⚠️ **Erro**: Não foi possível encontrar arquivos de mapeamento para o tipo de conversão " +
                f"'{tipo_conversao}'. Por favor, verifique se os arquivos JSON de mapeamento existem em " +
                "'/app/src/mapeamentos-de-para/mapeamentos-oc3-datamesh' ou '/app/src/mapeamentos-de-para/mapeamentos-sac-oc3'."
            )
            return
        
    # Buscar mapeamentos para a query
    resultados = mapping_manager.buscar_por_termos(query)
    resultados_filtrados = mapping_manager.filtrar_mapeamentos(resultados)
    
    # Armazenar resultados filtrados para uso posterior
    st.session_state["resultados_filtrados"] = resultados_filtrados
    
    if resultados_filtrados:
        # Verificar se há múltiplas possibilidades de mapeamento
        requer_selecao, info_mapeamentos, tabelas_multiplos_destinos = mapping_manager.verificar_multiplas_possibilidades(resultados_filtrados)
        
        # Armazenar informações de mapeamento para uso na interface
        st.session_state["info_mapeamentos"] = info_mapeamentos
        st.session_state["tabelas_multiplos_destinos"] = tabelas_multiplos_destinos
        
        # Sempre mostrar opções de seleção quando houver qualquer mapeamento
        st.session_state["aguardando_selecao"] = True
        
        # Mensagem inicial
        adicionar_mensagem("assistant", "**Analisando sua query SQL... Encontrei possibilidades de mapeamento.**")
        
        # Criar mensagens separadas para cada tabela
        todas_tabelas = list(info_mapeamentos.keys())
        
        for tabela in todas_tabelas:
            # Mensagem para cada tabela
            mensagem_tabela = f"Foi encontrado para a tabela (nome da tabela oc3) <{tabela}>:\n"
            
            # Se tem múltiplos destinos
            if tabela in tabelas_multiplos_destinos:
                destinos = tabelas_multiplos_destinos[tabela]
                for numero, nome_destino in destinos:
                    mensagem_tabela += f"{numero}- {nome_destino}\n"
            else:
                # Tabela com apenas uma opção
                destino = next(iter(info_mapeamentos[tabela]["destinos_info"].values()))["nome"]
                mensagem_tabela += f"1- {destino}\n"
            
            # Adicionar mensagem de cada tabela separadamente
            adicionar_mensagem("assistant", mensagem_tabela.rstrip())
        
        # Mensagem final de solicitação de seleção
        adicionar_mensagem("assistant", "Por favor, selecione os mapeamentos apropriados.")
    else:
        # Caso não encontre mapeamentos
        adicionar_mensagem(
            "assistant", 
            "Não encontrei mapeamentos correspondentes para sua query. Por favor, verifique se as tabelas estão corretas."
        )
    
    # Recarregar para exibir opções ou mensagem
    st.rerun()

def processar_mensagem_usuario(mensagem):
    """
    Processa a mensagem do usuário e determina a ação apropriada.
    
    Args:
        mensagem: Mensagem do usuário
    """
    # Limpar resultado anterior se existir
    if st.session_state.get("resultado_query"):
        st.session_state["resultado_query"] = None
        st.session_state["tabelas_utilizadas"] = []
    
    # Adiciona a mensagem original do usuário ao histórico
    adicionar_mensagem("user", mensagem)
    
    # Verificar se a mensagem parece ser uma mensagem multilinhas com múltiplas tabelas
    if ("\n" in mensagem and 
        ("Analisando sua query SQL" in mensagem or 
         "Foi encontrado para a tabela" in mensagem or 
         "Por favor" in mensagem)):
        
        # Processar mensagem multilinhas
        mensagens_processadas = processar_mensagem_multilinhas(mensagem)
        
        # Adicionar mensagens sequencialmente
        adicionar_mensagens_multiplas(mensagens_processadas)
        
        # Acionar rerun para mostrar as mensagens
        st.rerun()
        return

    # Tentar extrair uma query SQL do texto
    query_texto, contém_sql = extrair_query_sql(mensagem)
    
    # Guardar a query para referência (seja a original ou a extraída)
    st.session_state["ultima_query"] = query_texto
    
    # Armazenar o texto original completo também
    st.session_state["mensagem_original"] = mensagem
    
    # Se contém SQL, processar como query
    if contém_sql:
        # Mostrar mensagem se o texto foi diferente da query extraída
        if query_texto.strip() != mensagem.strip():
            tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
            adicionar_mensagem(
                "assistant", 
                f"Identifiquei uma query SQL em sua mensagem. Vou processar no modo {tipo_conversao}: ```sql\n{query_texto}\n```"
            )
        
        # Validar a query
        validacao_resultado = validar_query_simplificada(query_texto)
                
        if validacao_resultado["status"] == "Sucesso":
            # Processar como query SQL válida
            processar_query_valida(query_texto)
        else:
            # Query SQL inválida
            mensagem_erro = validacao_resultado["mensagem"]
            
            # Mostrar resposta com erro de validação
            adicionar_mensagem(
                "assistant", 
                f"⚠️ {mensagem_erro}"
            )
    else:
        # Processar como conversa normal
        tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
        resposta = f"Entendi! Por favor, digite uma query SQL para que eu possa converter no modo {tipo_conversao}."
        
        # Adicionar resposta ao histórico
        adicionar_mensagem(
            "assistant", 
            resposta
        )

def processar_conversao():
    """Processa a conversão da query usando Lambda ou simulação."""
    logger.info("INICIANDO PROCESSAMENTO DE CONVERSÃO")
    
    with st.spinner("Processando a conversão..."):
        try:
            # Obter o tipo de conversão atual
            tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
            
            # Obter a query SQL e a mensagem original completa do usuário
            query_original = st.session_state.get("ultima_query", "")
            mensagem_original = st.session_state.get("mensagem_original", query_original)
            mapeamentos_selecionados = st.session_state.get("tabelas_utilizadas", [])
            
            logger.info(f"Query original: {query_original}")
            logger.info(f"Total de mapeamentos selecionados: {len(mapeamentos_selecionados)}")
            
            # Obter o gerenciador de mapeamentos atual
            mapping_manager = st.session_state.get("mapping_manager")
            
            # Agrupar os mapeamentos no formato desejado para processamento
            mapeamentos_agrupados = mapping_manager.agrupar_mapeamentos_para_lambda(mapeamentos_selecionados)
            
            # Tentar inicializar cliente Bedrock
            bedrock_runtime = None
            try:
                bedrock_runtime = boto3.client(
                    'bedrock-runtime',
                    region_name="us-east-1",
                    aws_access_key_id=os.getenv("AWS_ACCESS_KEY_ID"),
                    aws_secret_access_key=os.getenv("AWS_SECRET_ACCESS_KEY"),
                    aws_session_token=os.getenv("AWS_SESSION_TOKEN")
                )
                logger.info("Cliente Bedrock Runtime inicializado com sucesso")
            except Exception as e:
                logger.warning(f"Não foi possível inicializar cliente Bedrock: {e}")
                logger.info("Usando modo de simulação para converter a query")
            
            # Criar conversor apropriado
            conversor = criar_conversor(tipo_conversao, bedrock_runtime)
            
            # Converter a query
            query_convertida = conversor.converter_query(
                query_original, 
                mapeamentos_agrupados,
                contexto_adicional=mensagem_original if mensagem_original != query_original else None
            )
            
            # Armazenar o resultado no estado da sessão
            logger.info(f"Query convertida: {query_convertida}")
            st.session_state["resultado_query"] = {
                "original": query_original,
                "convertida": query_convertida,
                "mensagem_original": mensagem_original,
                "tipo_conversao": tipo_conversao
            }
            
            # Adicionar uma mensagem marcadora para o resultado
            adicionar_mensagem(
                "assistant", 
                f"Resultado da conversão ({tipo_conversao})",
                is_result=True  # Marcador especial para identificar o resultado
            )
            
            logger.info("Processamento concluído com sucesso!")
            
        except Exception as e:
            logger.error(f"ERRO no processamento: {str(e)}")
            error_traceback = traceback.format_exc()
            logger.error(error_traceback)
            
            # Adicionar mensagem de erro
            adicionar_mensagem(
                "assistant", 
                f"Ocorreu um erro ao processar sua query: {str(e)}"
            )
        
        # Limpar estado de espera
        st.session_state["esperando_resultado"] = False
        
        # Recarregar a página
        st.rerun()



============== state maneger

# state_manager.py
import os
import json
import streamlit as st
# Importar do mesmo diretório usando importação relativa
from .mapping_utils import MappingManager
from logger_config import setup_logger

logger = setup_logger()

def inicializar_estado():
    """Inicializa o estado da sessão Streamlit."""
    # Inicializar estado da interface do chat
    if "mensagens" not in st.session_state:
        st.session_state["mensagens"] = []
    if "aguardando_selecao" not in st.session_state:
        st.session_state["aguardando_selecao"] = False
    if "mostrar_selecao" not in st.session_state:
        st.session_state["mostrar_selecao"] = False
    if "esperando_resultado" not in st.session_state:
        st.session_state["esperando_resultado"] = False
    if "ultima_query" not in st.session_state:
        st.session_state["ultima_query"] = ""
    if "resultado_query" not in st.session_state:
        st.session_state["resultado_query"] = None
    if "tabelas_utilizadas" not in st.session_state:
        st.session_state["tabelas_utilizadas"] = []
    if "tipo_processamento" not in st.session_state:
        st.session_state["tipo_processamento"] = ""
    if "resultados_filtrados" not in st.session_state:
        st.session_state["resultados_filtrados"] = []
    if "tipo_conversao" not in st.session_state:
        st.session_state["tipo_conversao"] = "OC3_PARA_DATAMESH"  # Valor padrão
    
    # Carregar mapeamentos
    _carregar_mapeamentos()

def _carregar_mapeamentos():
    """Carrega os mapeamentos para os diferentes tipos de conversão."""
    try:
        # Inicializar gerenciadores de mapeamentos
        if "mapping_manager_oc3_datamesh" not in st.session_state:
            logger.info("Inicializando gerenciador de mapeamentos OC3-DataMesh")
            
            # Criar gerenciador sem especificar caminho (detecção automática)
            manager = MappingManager(tipo_conversao="OC3_PARA_DATAMESH")
            mapeamentos = manager.carregar_mapeamentos()
            
            # Se não encontrou mapeamentos, registrar alerta
            if not mapeamentos:
                logger.warning("Nenhum mapeamento OC3-DataMesh encontrado nos diretórios verificados")
            
            st.session_state["mapping_manager_oc3_datamesh"] = manager
            st.session_state["mapeamentos_oc3_datamesh"] = mapeamentos
        
        if "mapping_manager_sac_oc3" not in st.session_state:
            logger.info("Inicializando gerenciador de mapeamentos SAC-OC3")
            
            # Criar gerenciador sem especificar caminho (detecção automática)
            manager = MappingManager(tipo_conversao="SAC_PARA_OC3")
            mapeamentos = manager.carregar_mapeamentos()
            
            # Se não encontrou mapeamentos, registrar alerta
            if not mapeamentos:
                logger.warning("Nenhum mapeamento SAC-OC3 encontrado nos diretórios verificados")
            
            st.session_state["mapping_manager_sac_oc3"] = manager
            st.session_state["mapeamentos_sac_oc3"] = mapeamentos
        
        # Compatibilidade com código existente - usar os mapeamentos do tipo atual
        tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
        if tipo_conversao == "OC3_PARA_DATAMESH":
            st.session_state["mapeamentos"] = st.session_state.get("mapeamentos_oc3_datamesh", [])
            st.session_state["mapping_manager"] = st.session_state.get("mapping_manager_oc3_datamesh")
        else:  # SAC_PARA_OC3
            st.session_state["mapeamentos"] = st.session_state.get("mapeamentos_sac_oc3", [])
            st.session_state["mapping_manager"] = st.session_state.get("mapping_manager_sac_oc3")
    
    except Exception as e:
        logger.error(f"Erro ao carregar mapeamentos: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Garantir que temos pelo menos managers vazios e listas vazias
        if "mapping_manager_oc3_datamesh" not in st.session_state:
            st.session_state["mapping_manager_oc3_datamesh"] = MappingManager(tipo_conversao="OC3_PARA_DATAMESH")
            st.session_state["mapeamentos_oc3_datamesh"] = []
        
        if "mapping_manager_sac_oc3" not in st.session_state:
            st.session_state["mapping_manager_sac_oc3"] = MappingManager(tipo_conversao="SAC_PARA_OC3")
            st.session_state["mapeamentos_sac_oc3"] = []
        
        # Garantir que temos os valores para o tipo atual
        tipo_conversao = st.session_state.get("tipo_conversao", "OC3_PARA_DATAMESH")
        if tipo_conversao == "OC3_PARA_DATAMESH":
            st.session_state["mapeamentos"] = st.session_state.get("mapeamentos_oc3_datamesh", [])
            st.session_state["mapping_manager"] = st.session_state.get("mapping_manager_oc3_datamesh")
        else:  # SAC_PARA_OC3
            st.session_state["mapeamentos"] = st.session_state.get("mapeamentos_sac_oc3", [])
            st.session_state["mapping_manager"] = st.session_state.get("mapping_manager_sac_oc3")

def adicionar_mensagem(role, texto, is_result=False, is_html=False):
    """
    Adiciona mensagem ao histórico de chat.
    
    Args:
        role: Papel da mensagem ('user' ou 'assistant')
        texto: Texto da mensagem
        is_result: Flag para indicar se é um resultado
        is_html: Flag para indicar se o conteúdo pode conter HTML
    """
    # Limpar HTML indesejado, exceto quando explicitamente permitido
    if not is_html:
        texto = texto.replace('</div>', '').replace('<div>', '').strip()
    
    if "mensagens" not in st.session_state:
        st.session_state["mensagens"] = []
    
    # Preparar o dicionário de mensagem
    mensagem = {
        "role": role,
        "text": texto,
        "is_result": is_result
    }
    
    # Adicionar is_html apenas se for True
    if is_html:
        mensagem["is_html"] = is_html
    
    st.session_state["mensagens"].append(mensagem)

def adicionar_mensagens_multiplas(mensagens):
    """
    Adiciona múltiplas mensagens sequencialmente ao histórico do chat.
    
    Args:
        mensagens: Lista de mensagens a serem adicionadas
    """
    for mensagem in mensagens:
        adicionar_mensagem("assistant", mensagem)

def limpar_historico():
    """Limpa o histórico de mensagens."""
    st.session_state["mensagens"] = []

def limpar_resultado():
    """Limpa o resultado de uma consulta anterior."""
    st.session_state["resultado_query"] = None
    st.session_state["tabelas_utilizadas"] = []

def atualizar_tipo_conversao(tipo_conversao):
    """
    Atualiza o tipo de conversão atual.
    
    Args:
        tipo_conversao: Novo tipo de conversão
    """
    if tipo_conversao != st.session_state.get("tipo_conversao"):
        st.session_state["tipo_conversao"] = tipo_conversao
        
        # Atualizar mapeamentos ativos
        if tipo_conversao == "OC3_PARA_DATAMESH":
            st.session_state["mapeamentos"] = st.session_state["mapeamentos_oc3_datamesh"]
            st.session_state["mapping_manager"] = st.session_state["mapping_manager_oc3_datamesh"]
        else:  # SAC_PARA_OC3
            st.session_state["mapeamentos"] = st.session_state["mapeamentos_sac_oc3"]
            st.session_state["mapping_manager"] = st.session_state["mapping_manager_sac_oc3"]

============== app.py

# app.py - Versão refatorada
import streamlit as st
from ui import show_ui
from chatbot.main import handle_chat
import traceback
import os
import json
from logger_config import setup_logger

# Configura o logger
logger = setup_logger()
logger.info("Aplicação Streamlit iniciada com sucesso!")

# Configuração da Página
st.set_page_config(
    page_title="Assistente SQL Converter", 
    layout="wide",
    menu_items={
        'Get Help': 'https://github.com/seu-usuario/assistente-sql-converter',
        'Report a bug': "https://github.com/seu-usuario/assistente-sql-converter/issues",
        'About': "### Assistente de Conversão SQL\nConverte queries entre sistemas diferentes - OC3, DataMesh e SAC."
    }
)

def diagnosticar_todos_json():
    """Encontra todos os arquivos JSON no sistema."""
    from chatbot.mapping_utils import listar_todos_arquivos_json


    listar_todos_arquivos_json("/app")

def show_campo_search():
    """Exibe interface de busca por campos, adaptada para OC3_PARA_DATAMESH e SAC_PARA_OC3."""
    
    # CÓDIGO DE DIAGNÓSTICO ADICIONADO
    logger.info("\n==== DIAGNÓSTICO DE CAMPO_SEARCH ====")
    # Verificar vários caminhos possíveis
    caminhos_para_verificar = [
        # Caminho absoluto informado
        "/app/src/mapeamentos-de-para/mapeamentos-oc3-datamesh",
        # Caminho relativo à raiz
        os.path.abspath("mapeamentos-de-para/mapeamentos-oc3-datamesh"),
        # Caminho relativo ao diretório atual
        os.path.join(os.getcwd(), "mapeamentos-de-para/mapeamentos-oc3-datamesh"),
        # Caminho relativo ao diretório do script
        os.path.join(os.path.dirname(os.path.abspath(__file__)), "mapeamentos-de-para/mapeamentos-oc3-datamesh"),
        # Caminho relativo ao diretório pai do script
        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "mapeamentos-de-para/mapeamentos-oc3-datamesh"),
    ]
    
    logger.info(f"Diretório atual: {os.getcwd()}")
    logger.info(f"Diretório do script: {os.path.dirname(os.path.abspath(__file__))}")
    
    for caminho in caminhos_para_verificar:
        logger.info(f"\nVerificando caminho: {caminho}")
        if os.path.exists(caminho):
            logger.info(f"✅ Diretório existe!")
            arquivos = os.listdir(caminho)
            logger.info(f"Arquivos encontrados: {arquivos}")
            jsons = [f for f in arquivos if f.endswith('.json')]
            if jsons:
                logger.info(f"✅ Arquivos JSON encontrados: {jsons}")
                # Tentar ler o primeiro arquivo
                try:
                    import json
                    with open(os.path.join(caminho, jsons[0]), 'r', encoding='utf-8') as f:
                        dados = json.load(f)
                    logger.info(f"✅ Arquivo JSON lido com sucesso! Tipo de dados: {type(dados)}")
                    if isinstance(dados, list):
                        logger.info(f"Lista com {len(dados)} itens")
                    elif isinstance(dados, dict):
                        logger.info(f"Dicionário com chaves: {list(dados.keys())}")
                except Exception as e:
                    logger.info(f"❌ Erro ao ler arquivo: {e}")
            else:
                logger.info("❌ Nenhum arquivo JSON encontrado")
        else:
            logger.info("❌ Diretório não existe")
    logger.info("==== FIM DO DIAGNÓSTICO ====\n")
    
    bloquear = st.session_state.get("chat_em_progresso", False)

    if bloquear:
        st.warning("⚠️ A busca de campos está desativada enquanto o chat está em andamento. Clique em 'Iniciar Nova Conversão' para liberar.")
        st.markdown("<div style='opacity: 0.5; pointer-events: none;'>", unsafe_allow_html=True)


def diagnosticar_ambiente():
    """Diagnóstico inicial do ambiente de execução."""
    logger.info("=== DIAGNÓSTICO DO AMBIENTE ===")
    logger.info(f"Diretório atual: {os.getcwd()}")
    
    try:
        logger.info(f"Conteúdo do diretório atual: {os.listdir('.')}")
    except Exception as e:
        logger.error(f"Erro ao listar diretório atual: {e}")
    
    # Verificar caminhos importantes
    caminhos_para_verificar = [
        "/app/src/mapeamentos-de-para",
        "/app/src/mapeamentos-de-para/mapeamentos-oc3-datamesh",
        "/app/src/mapeamentos-de-para/mapeamentos-sac-oc3",
        os.path.join(os.getcwd(), "mapeamentos-de-para"),
        os.path.join(os.getcwd(), "mapeamentos-de-para", "mapeamentos-oc3-datamesh"),
        os.path.join(os.getcwd(), "mapeamentos-de-para", "mapeamentos-sac-oc3"),
    ]
    
    for caminho in caminhos_para_verificar:
        logger.info(f"Verificando: {caminho}")
        if os.path.exists(caminho):
            logger.info(f"  ✅ Existe!")
            try:
                arquivos = os.listdir(caminho)
                logger.info(f"  Conteúdo: {arquivos}")
                
                jsons = [f for f in arquivos if f.endswith('.json')]
                if jsons:
                    logger.info(f"  ✅ Arquivos JSON: {jsons}")
                    
                    # Verificar primeiro arquivo JSON
                    try:
                        primeiro_json = os.path.join(caminho, jsons[0])
                        with open(primeiro_json, 'r', encoding='utf-8') as f:
                            dados = json.load(f)
                            logger.info(f"  ✅ Arquivo JSON válido: {len(dados) if isinstance(dados, list) else 'dados de tipo ' + str(type(dados))}")
                    except Exception as e:
                        logger.error(f"  ❌ Erro ao ler JSON: {e}")
                else:
                    logger.warning(f"  ⚠️ Nenhum arquivo JSON encontrado")
            except Exception as e:
                logger.error(f"  ❌ Erro ao listar diretório: {e}")
        else:
            logger.warning(f"  ⚠️ Não existe!")
    
    logger.info("=== FIM DO DIAGNÓSTICO ===")

# Verificar diretórios e criar se necessário
def verificar_diretorios_mapeamentos():
    """Verifica se os diretórios de mapeamentos existem."""
    # Verificar múltiplos possíveis caminhos base
    caminhos_base = [
        "/app/src",
        os.getcwd(),
        os.path.dirname(os.path.abspath(__file__)),
    ]
    
    # Iterar sobre cada caminho base e verificar diretórios
    for base_path in caminhos_base:
        logger.info(f"Verificando base path: {base_path}")
        
        # Verificar diretório de mapeamentos principal
        caminho_mapeamentos = os.path.join(base_path, "mapeamentos-de-para")
        if not os.path.exists(caminho_mapeamentos):
            try:
                os.makedirs(caminho_mapeamentos, exist_ok=True)
                logger.info(f"Diretório principal criado: {caminho_mapeamentos}")
            except Exception as e:
                logger.warning(f"Erro ao criar diretório {caminho_mapeamentos}: {e}")
                continue  # Tentar próximo caminho base
        
        # Verificar diretório de mapeamentos OC3-DataMesh
        caminho_oc3_datamesh = os.path.join(caminho_mapeamentos, "mapeamentos-oc3-datamesh")
        if not os.path.exists(caminho_oc3_datamesh):
            try:
                os.makedirs(caminho_oc3_datamesh, exist_ok=True)
                logger.info(f"Diretório OC3-DataMesh criado: {caminho_oc3_datamesh}")
            except Exception as e:
                logger.warning(f"Erro ao criar diretório {caminho_oc3_datamesh}: {e}")
        else:
            logger.info(f"Diretório OC3-DataMesh já existe: {caminho_oc3_datamesh}")
            arquivos = os.listdir(caminho_oc3_datamesh)
            jsons = [f for f in arquivos if f.endswith('.json')]
            if not jsons:
                logger.warning(f"Nenhum arquivo JSON encontrado em {caminho_oc3_datamesh}")
        
        # Verificar diretório de mapeamentos SAC-OC3
        caminho_sac_oc3 = os.path.join(caminho_mapeamentos, "mapeamentos-sac-oc3")
        if not os.path.exists(caminho_sac_oc3):
            try:
                os.makedirs(caminho_sac_oc3, exist_ok=True)
                logger.info(f"Diretório SAC-OC3 criado: {caminho_sac_oc3}")
            except Exception as e:
                logger.warning(f"Erro ao criar diretório {caminho_sac_oc3}: {e}")
        else:
            logger.info(f"Diretório SAC-OC3 já existe: {caminho_sac_oc3}")
            arquivos = os.listdir(caminho_sac_oc3)
            jsons = [f for f in arquivos if f.endswith('.json')]
            if not jsons:
                logger.warning(f"Nenhum arquivo JSON encontrado em {caminho_sac_oc3}")
        
        # Se chegou até aqui, os diretórios foram verificados/criados com sucesso
        return
    
    # Se chegou aqui, nenhum caminho base funcionou
    logger.error("Não foi possível verificar/criar diretórios de mapeamentos em nenhum caminho base")

try:
    # Diagnóstico inicial do ambiente
    diagnosticar_ambiente()

    diagnosticar_todos_json()
    
    # Verificar diretórios de mapeamentos
    verificar_diretorios_mapeamentos()
    
    # Exibir UI (Interface)
    logger.info("Carregando interface da aplicação...")
    show_ui()
    logger.info("Interface carregada com sucesso.")

    # Rodar Chatbot
    logger.info("Iniciando execução do chatbot...")
    handle_chat()
    logger.info("Chatbot executado com sucesso.")

except Exception as e:
    logger.error(f"Erro na aplicação: {str(e)}")
    logger.error(traceback.format_exc())

    st.error(f"Erro na aplicação: {str(e)}")
    with st.expander("Detalhes do erro"):
        st.code(traceback.format_exc(), language="python")


